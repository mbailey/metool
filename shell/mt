#!/usr/bin/env bash
# mt - source this file

mt() {
  # Convert DEBUG=1 to MT_LOG_LEVEL=DEBUG
  if [[ -n "${DEBUG:-}" ]]; then
    export MT_LOG_LEVEL=DEBUG
  fi

  # Get path to script and root of project
  command -v realpath &>/dev/null || {
    echo "Error: 'realpath' is required but not found. Please install 'coreutils' (e.g. 'brew install coreutils' on macOS)." >&2
    return 1
  }
  SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}")"
  SCRIPT_DIR="$(dirname -- "${SCRIPT_PATH}")"
  export MT_ROOT="$(dirname -- "${SCRIPT_DIR}")"

  # Load core functions
  source "${MT_ROOT}/lib/functions.sh" # Must be loaded first (I think)

  source "${MT_ROOT}/lib/colors.sh"
  source "${MT_ROOT}/lib/edit.sh"
  source "${MT_ROOT}/lib/git.sh"
  source "${MT_ROOT}/lib/path.sh"
  source "${MT_ROOT}/lib/stow.sh"
  source "${MT_ROOT}/lib/sync.sh"
  source "${MT_ROOT}/lib/deps.sh"
  source "${MT_ROOT}/lib/systemd.sh"
  source "${MT_ROOT}/lib/repos.sh"
  source "${MT_ROOT}/lib/package.sh"
  source "${MT_ROOT}/lib/working-set.sh" # MT-11 working set helpers
  source "${MT_ROOT}/lib/module.sh" # MT-11 module commands
  source "${MT_ROOT}/lib/service.sh" # MT-11 service commands

  # Initialise globals
  : ${XDG_LOCAL_BIN:="${HOME}/.local/bin"}

  # Dirs for pkg files/symlinks
  # Symlink or copy to here and then symlink to target
  # Provides single choke point for MT packages (rename dir to disable)
  : ${MT_PKG_DIR:="${HOME}/.metool"}
  export MT_PKG_DIR

  # Working set directories (MT-11)
  : ${MT_MODULES_DIR:="${MT_PKG_DIR}/modules"}
  : ${MT_PACKAGES_DIR:="${MT_PKG_DIR}/packages"}
  export MT_MODULES_DIR
  export MT_PACKAGES_DIR

  _mt_log DEBUG "SCRIPT_PATH=${SCRIPT_PATH}"
  _mt_log DEBUG "MT_ROOT=${MT_ROOT}"

  # Ensure pkg dirs exist
  command mkdir -p "${MT_PKG_DIR}/bin"
  # mkdir -p "${MT_PKG_DIR}/config" # Not used currently
  command mkdir -p "${MT_PKG_DIR}/shell"

  # Ensure working set dirs exist (MT-11)
  command mkdir -p "${MT_MODULES_DIR}"
  command mkdir -p "${MT_PACKAGES_DIR}"

  # Check for global debug flag before other argument processing
  if [[ "${1:-}" == "--debug" ]] || [[ "${1:-}" == "-d" ]]; then
    export MT_LOG_LEVEL=DEBUG
    shift  # Remove debug flag from arguments
  fi

  # Parse command
  if [[ $# -eq 0 ]]; then

    ## Ensure MT_BIN_DIR is in PATH
    _mt_path_prepend "${MT_PKG_DIR}/bin"

    # Source all files under MT_PKG_DIR/shell
    if [[ -d "${MT_PKG_DIR}/shell" ]]; then
      # Detect current shell
      local current_shell=""
      if [[ -n "${BASH_VERSION}" ]]; then
        current_shell="bash"
      elif [[ -n "${ZSH_VERSION}" ]]; then
        current_shell="zsh"
      fi
      _mt_log DEBUG "Detected shell: $current_shell"

      while IFS= read -r -d '' file; do
        if [[ "$(realpath "$file")" == "${SCRIPT_PATH}" ]]; then
          #if [[ "$(realpath "$file")" =~ "${MT_ROOT}" ]]; then
          _mt_log DEBUG "Not sourcing myself ($SCRIPT_PATH): $file"
          continue
        fi

        # Check file extension for shell-specific sourcing
        local filename="$(basename "$file")"
        local ext=""
        if [[ "$filename" == *.* ]]; then
          ext="${filename##*.}"
        fi

        # Determine if file should be sourced
        local should_source=true

        case "$ext" in
          bash)
            # .bash files only in bash
            if [[ "$current_shell" != "bash" ]]; then
              should_source=false
            fi
            ;;
          zsh)
            # .zsh files only in zsh
            if [[ "$current_shell" != "zsh" ]]; then
              should_source=false
            fi
            ;;
          sh|"")
            # .sh files and files with no extension work in all shells
            should_source=true
            ;;
          *)
            # Other extensions (e.g., .py, .md) - source in all shells
            should_source=true
            ;;
        esac

        if [[ "$should_source" == "true" ]]; then
          _mt_log DEBUG "Sourcing $file"
          source "$file"
        else
          _mt_log DEBUG "Skipping $file (shell-specific: .$ext, current: $current_shell)"
        fi
      done < <(command find -L "${MT_PKG_DIR}/shell" -type f -not -name ".*" -print0 | command sort -z)
      # Setup bash completion for aliases (only if bash-completion is loaded)
      if type -t _complete_alias &>/dev/null; then
        complete -F _complete_alias "${!BASH_ALIASES[@]}"
      fi
    fi

  else

    case $1 in
    -h | --help)
      echo "Usage: mt [-d|--debug] [command]"
      echo
      echo "Global Options:"
      echo "  -d, --debug            Enable debug output"
      echo
      echo "Core Commands:"
      echo "  cd [TARGET]            Change to MT_ROOT or specified target"
      echo "  edit TARGET            Edit function, executable or file"
      echo "  git <subcommand>       Git repository management"
      echo "    clone URL [PATH]     Clone a git repository to a canonical location"
      echo "    repos                List git repositories"
      echo "    sync [DIR|FILE]      Sync repositories from repos.txt manifest file"
      echo "    trusted [PATH]       Check if repository is trusted"
      echo "  install [options] [DIR] Symlink package directories: bin,config,shell (defaults to MT_ROOT)"
      echo "  modules                List all metool modules (collections of packages)"
      echo "  packages               List all metool packages with their parent modules"
      echo "  package <subcommand>   Package management"
      echo "    new NAME [PATH]      Create a new package from template"
      echo "  components             List all package components (bin, shell, config, etc.)"
      echo "  update                 Update metool from git"
      echo "  reload                 Reload metool"
      echo "  deps [--install]       Check metool dependencies (--install to auto-install on macOS)"
      echo "  clean                  Remove dangling symlinks from ~/.metool"
      echo "  -h, --help             Show this help message and exit"
      echo
      ;;
    cd)
      shift
      if [[ $# -eq 1 ]]; then
        _mt_log DEBUG "\$1=$1"
        _mt_cd "$1"
      else
        echo "Changing directory to: $MT_ROOT"
        cd "$MT_ROOT"
      fi
      ;;
    git)
      shift
      _mt_git "$@"
      ;;
    clone)
      # Keep for backwards compatibility
      shift
      _mt_clone "$@"
      ;;
    edit)
      shift
      _mt_edit "$@"
      ;;
    install)
      shift
      # If no arguments provided, default to MT_ROOT
      if [[ $# -eq 0 ]]; then
        # Installing metool itself - check dependencies first
        echo "Checking dependencies before installing metool..."
        echo ""
        if ! _mt_check_deps; then
          echo ""
          echo "âŒ Cannot install metool without required dependencies."
          if command -v brew &>/dev/null; then
            echo ""
            echo "ðŸ’¡ Run 'mt deps --install' to install missing dependencies with Homebrew"
          fi
          return 1
        fi
        echo ""
        echo "Installing metool..."
        _mt_stow "$MT_ROOT"
      else
        _mt_stow "$@"
      fi
      ;;
    update)
      shift
      _mt_update
      ;;
    reload)
      shift
      _mt_source "${MT_ROOT}/shell/mt"
      ;;
    module)
      shift
      _mt_module "$@"
      ;;
    modules)
      shift
      _mt_get_modules | columnise
      ;;
    packages)
      shift
      _mt_get_packages | columnise
      ;;
    package)
      shift
      _mt_package "$@"
      ;;
    components)
      shift
      # Get all packages and list their components
      local packages=$(_mt_get_packages)

      # If an argument is provided, filter by package name
      if [[ $# -eq 1 ]]; then
        packages=$(echo "$packages" | command grep -E "^$1\t")
      fi

      # Print header
      printf "%-15s %-20s %-40s %s\n" "COMPONENT" "PACKAGE" "MODULE" "PATH"
      printf "%-15s %-20s %-40s %s\n" "----------" "-------" "------" "----"

      while IFS=$'\t' read -r pkg_name module_name pkg_dir; do
        # For each package directory, list its components
        for component in bin shell config docs lib libexec; do
          if [[ -d "$pkg_dir/$component" ]]; then
            printf "%-15s %-20s %-40s %s\n" "$component" "$pkg_name" "$module_name" "${pkg_dir}/${component}"
          fi
        done
      done <<<"$packages"
      ;;
    repos)
      # Keep for backwards compatibility - redirect to git repos
      shift  
      _mt_repos_discover "$@"
      ;;
    sync)
      # Keep for backwards compatibility - redirect to git sync
      shift
      _mt_sync "$@"
      ;;
    deps)
      shift
      _mt_deps "$@"
      ;;
    clean)
      shift
      _mt_clean "$@"
      ;;
    enable)
      shift
      _mt_enable "$@"
      ;;
    disable)
      shift
      _mt_disable "$@"
      ;;
    help)
      # Redirect help to -h/--help handler
      mt --help
      ;;
    *)
      _mt_error "Unknown command: $1"
      return 1
      ;;
    esac

  fi
}

mt "$@"
